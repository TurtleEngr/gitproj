#!/bin/bash
# Test suite to gitproj functions and scripts.

# ========================================
fUsage()
{
    fComUsage -i -s short -f $cCurDir/$cName

    # This is the start of the testing internal documentation. See:
    # fGitProjComInternalDoc()
    return

    cat <<\EOF >/dev/null
=internal-pod

=internal-head1 gitproj-com.test

=internal-head2 gitproj-com.test Usage

=internal-cut

=pod

=for text ========================================

=for html <hr/>

=head1 NAME

gitproj-com.test - test the gitproj-com.inc functions

=head1 SYNOPSIS

        gitproj-com.test [testName,testName,...]

=head1 DESCRIPTION

shunit2.1 is used to run the unit tests. If no test function names are
listed, then all of the test functions will be run.

=head1 RETURN VALUE

0 - if OK

=head1 ERRORS

=head1 EXAMPLES

=head1 ENVIRONMENT

=head1 FILES

=head1 SEE ALSO

shunit2.1

=head1 NOTES

=head1 CAVEATS

=head1 DIAGNOSTICS

=head1 BUGS

=head1 RESTRICTIONS

=head1 AUTHOR

=head1 HISTORY

$Revision: 1.2 $ $Date: 2021/09/08 01:39:35 $ GMT 

=cut
EOF
}

# ========================================

# --------------------------------
fComUDebug()
{
    if [ ${gpUnitDebug:-0} -ne 0 ]; then
        echo "fComUDebug: $*"
    fi
    return
    cat <<EOF

=internal-head2 Com Unit Test Functions

EOF
} # fComUDebug

# --------------------------------
fComSetupDev()
{
    cTestFiles=test-gitproj.tgz

    cTestDestDir=$cBin/../..
    cd $cTestDestDir
    cTestDestDir=$PWD
    cd - >/dev/null

    if [ -r $cBin/../doc/test/$cTestFiles ]; then
        cTestSrcDir=$cBin/../doc/test
    fi
    if [ -r $cBin/../../$cTestFiles ]; then
        cTestSrcDir=$cBin/../..
    fi
    if [ -z "$cTestSrcDir" ]; then
        fError -m "Error: Cannot setup tests." -l $LINENO
    fi
    cd $cTestSrcDir
    cTestSrcDir=$PWD
    cd - >/dev/null
}

# --------------------------------
fComSetupProd()
{
    echo TBD
}

# --------------------------------
fComSetup()
{
    if [ "$cBin" = "/usr/lib/git-core" ]; then
        fComSetupProd
    elif [ -d $cBin/../.git ]; then
        fComSetupDev
    else
        fError -m "Error: Cannot setup tests." -l $LINENO
    fi

    cDatProj1=project/george
    cDatProj2=project/paulb
    cDatProj1Big="src/raw/MOV001.mp4 src/raw/MOV001.MP3 src/final/george.mp4"
    cDatProj2Big="src/raw/MOV001.mp4 src/raw/MOV001.MP3 src/final/paulb.mp4"
    cDatMount1=$cTestDestDir/test/root/mnt/disk-2
    cDatMount2=$cTestDestDir/test/root/mnt/usb-misc/files-2021-08-12
    cDatMount3=$cTestDestDir/test/root/mnt/usb-video/video-2020-04-02

    return
}

# --------------------------------
fCreateTestEnv()
{
    if [ -d $cTestDestDir/test ]; then
        find $cTestDestDir/test -type l -exec rm {} \;
        rm -rf $cTestDestDir/test
    fi
    cd $cTestDestDir >/dev/null
    tar -xzf $cTestSrcDir/$cTestFiles

    cd test/root/home/john >/dev/null
    cHome=$HOME
    HOME=$PWD
    cd $cBin >/dev/null
    cp $cBin/../doc/config/global.gitproj.config $HOME/.gitproj.config
    cp $cBin/../doc/config/test-dev.gitproj-test.config $HOME/.gitproj-test.config
    fComSetConfig -g -k "include.path" -v ".gitproj.config"
    fComSetConfig -g -k "include.path" -v ".gitproj-test.config" -a

    if [ -d $cBin/../.git ]; then
        # We are testing from the git clone, so set GIT_DIR
        tGitTop=$(git rev-parse --show-toplevel)
        sed -i "s;GIT_DIR;$tGitTop;g" $HOME/.gitproj-test.config
    fi
} # fCreateTestEnv

# --------------------------------
oneTimeSetUp()
{
    local tGitTop

    # Save global values
    export tDefault_cBin=$cBin
    export tDefault_cCurDir=$cCurDir
    export tDefault_cName=$cName
    export tDefault_cPID=$cPID
    export tDefault_cVer=$cVer
    export tDefault_gErr=0
    export tDefault_gpDebug=0
    export tDefault_gpFacility=user
    export tDefault_gpLog=0
    export tDefault_gpVerbose=0

    return

    cat <<EOF >/dev/null
=internal-pod

=internal-head2 Test gitproj-com.inc

=internal-head3 oneTimeSetuUp

Currently this records all of the script's expected initial global
variable settings, defined in fComSetGlobals. If different, adjust the
tests as needed.

Env Var

 HOME - this is set to the test user's home dir
 gpUnitDebug - this can be manually set to 1 in unit test functions.

Calls:

 $cBin/gitproj-com.inc
 fComSetGlobals

=internal-cut
EOF
} # oneTimeSetUp

oneTimeTearDown()
{
    gpUnitDebug=1

    if [ -n "$cHome" ]; then
        HOME=$cHome
    fi

    # Remove all test files
    cd $cBin
    if [ $gpUnitDebug -eq 0 ] && [ -d $cTestDestDir/test ]; then
        find $cTestDestDir/test -type l -exec rm {} \;
        rm -rf $cTestDestDir/test
    fi
} # oneTimeTearDown

# --------------------------------
setUp()
{
    # Restore global values, before each test
    cBin=$tDefault_cBin
    cCurDir=$tDefault_cCurDir
    cName=$tDefault_cName
    cPID=$tDefault_cPID
    cVer=$tDefault_cVer
    gErr=$tDefault_gErr
    gpDebug=$tDefault_gpDebug
    gpFacility=$tDefault_gpFacility
    gpLog=$tDefault_gpLog
    gpVerbose=$tDefault_gpVerbose

    fCreateTestEnv

    gpUnitDebug=0
    return 0

    cat <<EOF >/dev/null
=internal-pod

=internal-head3 setUp

Before each test runs, this restores all of the script's initial
global variable settings,

=internal-cut
EOF
} # setUp

tearDown()
{
    git config --global --remove-section gitproj.testitd &>/dev/null
    gpUnitDebug=0
    return 0
} # tearDown

# ========================================

# --------------------------------
testSetup()
{
    assertTrue "$LINENO" "[ -x $cBin/gitproj-com.inc ]"
    assertTrue "$LINENO" "[ -r $cTestSrcDir/$cTestFiles ]"
    assertTrue "$LINENO" "[ -d $cTestDestDir ]"
    assertNotEquals "$LINENO" "$cHome" "$HOME"
    assertTrue "$LINENO" "[ -r $HOME/.gitproj.config ]"
    assertTrue "$LINENO" "[ -r $HOME/.gitproj-test.config ]"
    assertTrue "$LINENO" "[ -x $cBin/git-proj ]"

    for i in $cDatMount1 $cDatMount2 $cDatMount3; do
        fComUDebug "i=$i"
        assertTrue "$LINENO ${i##*/}" "[ -d $i ]"
    done
    for i in $cDatProj1 $cDatProj2; do
        fComUDebug "i=$i"
        assertTrue "$LINENO ${i}" "[ -d $HOME/$i ]"
    done
    for i in $cDatProj1Big; do
        fComUDebug "i=$i"
        assertTrue "$LINENO ${i}" "[ -r $HOME/$cDatProj1/$i ]"
    done
    for i in $cDatProj2Big $cDatProj2Big; do
        fComUDebug "i=$i"
        assertTrue "$LINENO ${i}" "[ -r $HOME/$cDatProj2/$i ]"
    done
}

# --------------------------------
testComInitialConfig()
{
    local tProg
    local tResult

    assertEquals "$LINENO tcic-1" "$PWD" "$cCurDir"
    assertTrue "$LINENO tcic-2" "[ -d $cCurDir ]"

    assertNotNull "$LINENO tcic-3" "$cBin"
    assertTrue "$LINENO tcic-4" "[ -d $cBin ]"
    assertTrue "$LINENO tcic-5" "[ -f $cBin/$cName ]"
    assertTrue "$LINENO tcic-6" "[ -x $cBin/$cName ]"
    assertTrue "$LINENO tcic-7" "[ -x $cBin/gitproj-com.inc ]"
    assertTrue "$LINENO tcic-8" "[ -x $cBin/gitproj-com.test ]"

    assertEquals "$LINENO tcic-10" "0" "$gpDebug"
    assertEquals "$LINENO tcic-11" "0" "$gpVerbose"
    assertEquals "$LINENO tcic-12" "0" "$gpLog"
    assertEquals "$LINENO tcic-13" "user" "$gpFacility"
    assertEquals "$LINENO tcic-14" "0" "$gErr"
    assertNull "$LINENO tcic-15" "$(echo $cVer | tr -d '.[:digit:]')"

    for tProg in logger pod2text pod2usage pod2html pod2man pod2markdown tidy awk tr; do
        which $tProg &>/dev/null
        assertTrue "$LINENO tcic-20 missing: $tProg" "[ $? -eq 0 ]"
    done
    return

    cat <<EOF >/dev/null
=internal-pod

=internal-head3 testInitialConfig

Verify all of the global variables are correctly defined. Look for
"ADJUST" comment for tests that might need to be changed for your
script.

=internal-cut
EOF
} # testInitialConfig

# --------------------------------
testComLog_MultiplePermutations()
{
    local tMsg
    local tLevel
    local tLine
    local tErr
    local tResult
    local tTestMsg

    # Check the format, for a number of settings
    gpLog=0
    gpVerbose=0
    gpDebug=0
    tMsg="Testing 123"
    tLine="458"
    tErr="42"

    for gpLog in 0 1; do
        for gpVerbose in 0 1; do
            for gpDebug in 0 1 2; do
                for tLevel in alert crit err warning notice info debug debug-1 debug-3; do
                    echo -n '.' 1>&2
                    tTestMsg="l-$gpLog.v-$gpVerbose.d-$gpDebug.$tLevel.fLog"
                    fComUDebug " "
                    fComUDebug "Call: fLog -p $tLevel -m \"$tMsg\" -l $tLine -e $tErr"
                    tResult=$(fLog -p $tLevel -m "$tMsg" -l $tLine -e $tErr 2>&1)
                    fComUDebug "tResult=$tResult"

                    if [ $gpVerbose -eq 0 ] && echo $tLevel | grep -Eq 'notice|info'; then
                        assertNull "$LINENO tcl1-$tTestMsg not notice,info" "$tResult"
                        continue
                    fi
                    if [ $gpVerbose -eq 1 ] && echo $tLevel | grep -Eq 'info'; then
                        assertNull "$LINENO tcl1-$tTestMsg not info" "$tResult"
                        continue
                    fi
                    if [ $gpDebug -eq 0 ] && [ "${tLevel%%-*}" = "debug" ]; then
                        assertNull "$LINENO tcl2-$tTestMsg not debug" "$tResult"
                        continue
                    fi
                    if [ $gpDebug -lt 2 ] && [ "$tLevel" = "debug-2" ]; then
                        assertNull "$LINENO tcl3-$tTestMsg not debug-2" "$tResult"
                        continue
                    fi
                    if [ $gpDebug -lt 3 ] && [ "$tLevel" = "debug-3" ]; then
                        assertNull "$LINENO tcl4-$tTestMsg not debug-3" "$tResult"
                        continue
                    fi
                    assertContains "$LINENO tcl5-$tTestMsg.name" "$tResult" "$cName"
                    assertContains "$LINENO tcl6-$tTestMsg.level" "$tResult" "$tLevel:"
                    assertContains "$LINENO tcl7-$tTestMsg.msg" "$tResult" "$tMsg"
                    assertContains "$LINENO tcl8-$tTestMsg.line" "$tResult" '['$tLine']'
                    assertContains "$LINENO tcl9-$tTestMsg.$tLevel.err" "$tResult" '('$tErr')'
                done # tLevel
            done     # gpDebug
        done         # gpVerbose
    done             # gpLog

    echo 1>&2
    return

    cat <<EOF >/dev/null
=internal-pod

=internal-head3 testLog

Test fLog and fLog.

=internal-cut
EOF
} # testLog

# --------------------------------
testComSysLog()
{
    local tErr
    local tLevel
    local tLine
    local tMsg
    local tResult
    local tTestMsg

    # ADJUST? This is dependent on your syslog configuration.
    export tSyslog=/var/log/user.log
    #export tSyslog=/var/log/messages.log
    #export tSyslog=/var/log/syslog

    # Check syslog
    gpLog=1
    gpVerbose=0
    tMsg="Testing 123"
    #for tLevel in emerg alert crit err warning; do
    for tLevel in alert crit err warning; do
        echo -n '.' 1>&2
        tTestMsg="$tLevel.fLog"
        fComUDebug " "
        fComUDebug "Call: fLog -p $tLevel -m \"$tMsg\""
        tResult=$(fLog -p $tLevel -m "$tMsg" 2>&1)
        fComUDebug "tResult=$tResult"
        assertContains "$LINENO tcl11-$tTestMsg" "$tResult" "$tLevel:"
        tResult=$(tail -n1 $tSyslog)
        fComUDebug "syslog tResult=$tResult"
        assertContains "$LINENO tcl12-$tTestMsg" "$tResult" "$tLevel:"
        assertContains "$LINENO tcl13-$tTestMsg" "$tResult" "$tMsg"
    done
    echo 1>&2
    return

    cat <<EOF >/dev/null
=internal-pod

=internal-head3 testSysLog

Test fLog and fLog, and verify messages are in a syslog file.

=internal-cut
EOF
} # testSysLog

# --------------------------------
testComErrorLog()
{
    local tMsg
    local tLevel
    local tLine
    local tErr
    local tResult
    local tTestMsg

    gpLog=0
    gpVerbose=0
    local tMsg="Testing 123"
    local tLine="458"
    for gpLog in 0 1; do
        echo -n '.' 1>&2
        tTestMsg="l-$gpLog.fError"
        fComUDebug " "
        fComUDebug "Call: fError -m \"$tMsg\" -l $tLine"
        tResult=$(fError -m "$tMsg" -l $tLine 2>&1)
        fComUDebug "tResult=$tResult"
        assertContains "$LINENO tcel-$tTestMsg.name" "$tResult" "$cName"
        assertContains "$LINENO tcel-$tTestMsg.crit" "$tResult" "crit:"
        assertContains "$LINENO tcel-$tTestMsg.msg" "$tResult" "$tMsg"
        assertContains "$LINENO tcel-$tTestMsg.line" "$tResult" '['$tLine']'
        assertContains "$LINENO tcel-$tTestMsg.err" "$tResult" '('1')'
        assertContains "$LINENO tcel-$tTestMsg.usage" "$tResult" "Usage"
    done
    echo 1>&2
    return

    cat <<EOF >/dev/null
=internal-pod

=internal-head3 testErrorLog

Test fError and fError.

=internal-cut
EOF
} # testErrorLog

# --------------------------------
testComUsage()
{
    local tResult

    #-----
    tResult=$(fComUsage -s usage -f $cBin/$cName 2>&1)
    fComUDebug "tResult=$tResult"
    assertContains "$LINENO tcu-short" "$tResult" "Usage"

    #-----
    tResult=$(fComUsage -s foo -f $cBin/$cName 2>&1)
    fComUDebug "tResult=$tResult"
    assertContains "$LINENO tcu-s-foo.1" "$tResult" "DESCRIPTION"
    assertContains "$LINENO tcu-s-foo.2" "$tResult" "HISTORY"

    #-----
    tResult=$(fComUsage -f $cBin/$cName -s 2>&1)
    fComUDebug "tResult=$tResult"
    assertContains "$LINENO tcu-s-null.1" "$tResult" "crit: Internal: fComUsage: Value required"

    #-----
    tResult=$(fComUsage -s long -f $cBin/$cName 2>&1)
    assertContains "$LINENO tcu-long.1" "$tResult" "DESCRIPTION"
    assertContains "$LINENO tcu-long.2" "$tResult" "HISTORY"

    #-----
    tResult=$(fComUsage -s man -f $cBin/$cName 2>&1)
    assertContains "$LINENO tcu-man.1" "$tResult" '.IX Header "DESCRIPTION"'
    assertContains "$LINENO tcu-man.2" "$tResult" '.IX Header "HISTORY"'

    #-----
    tResult=$(fComUsage -s html -f $cBin/$cName -t "$cName Usage" 2>&1)
    assertContains "$LINENO tcu-html.1" "$tResult" '<li><a href="#DESCRIPTION">DESCRIPTION</a></li>'
    assertContains "$LINENO tcu-html.2" "$tResult" '<h1 id="HISTORY">HISTORY</h1>'
    assertContains "$LINENO tcu-html.3" "$tResult" "<title>$cName Usage</title>"

    #-----
    tResult=$(fComUsage -s md -f $cBin/$cName 2>&1)
    assertContains "$LINENO tcu-md.1" "$tResult" '# DESCRIPTION'
    assertContains "$LINENO tcu-md.2" "$tResult" '# HISTORY'

    #-----
    tResult=$(fComUsage -i -s long -f $cBin/$cName -f $cBin/gitproj-com.inc 2>&1)
    fComUDebug "tResult=$tResult"
    assertContains "$LINENO tcu-internal.1" "$tResult" 'Template Use'
    assertContains "$LINENO tcu-internal.2" "$tResult" 'fComSetGlobals'

    #-----
    tResult=$(fComUsage -i -s html -t "Internal Doc" -f $cBin/$cName -f $cBin/gitproj-com.inc -f $cBin/gitproj-com.test 2>&1)
    fComUDebug "tResult=$tResult"
    assertContains "$LINENO tcu-int-html.1" "$tResult" '<a href="#Template-Use">Template Use</a>'
    assertContains "$LINENO tcu-int-html.2" "$tResult" '<h3 id="fComSetGlobals">fComSetGlobals</h3>'
    assertContains "$LINENO tcu-int-html.3" "$tResult" '<title>Internal Doc</title>'
    assertContains "$LINENO tcu-int-html.4" "$tResult" '<h3 id="testComUsage">testComUsage</h3>'

    #-----
    tResult=$(fComUsage -i -s md -f $cBin/$cName -f $cBin/gitproj-com.inc -f $cBin/gitproj-com.test 2>&1)
    assertContains "$LINENO tcu-int-md.1" "$tResult" '## Template Use'
    assertContains "$LINENO tcu-int-md.2" "$tResult" '### fComSetGlobals'
    assertContains "$LINENO tcu-int-md.3" "$tResult" '### testComUsage'

    #-----
    tResult=$(fComUsage -a -s long -f $cBin/$cName -f $cBin/gitproj-com.inc 2>&1)
    assertContains "$LINENO long" "$tResult" "DESCRIPTION"
    
    #-----
    return

    cat <<EOF >/dev/null
=internal-pod

=internal-head3 testComUsage

Test fComUsage. Verify the different output styles work.

=internal-cut
EOF
} # testComUsage

# --------------------------------
testComFunctions()
{
    local tResult

    tResult=$(fComCheckDeps 2>&1)
    assertTrue "$LINENO tcf-fComCheckDep tResult=$tResult" "[ $? -eq 0 ]"

    tResult=$(fComSetGlobals 2>&1)
    assertTrue "$LINENO tcf-fComSetGlobals tResult=$tResult" "[ $? -eq 0 ]"
    return

    cat <<EOF >/dev/null
=internal-pod

=internal-head3 testComFunctions

Just verify these functions exist and run.

Calls:

 fComCheckDeps
 fComSetGlobals

=internal-cut
EOF
} # testComFunctions

# --------------------------------
testComSetConfigGlobal()
{
    local tResult
    local tGlobal=$HOME/.gitconfig

    assertTrue "$LINENO -g" "[ -r $tGlobal ]"

    grep -q '\[gitproj "testit"\]' $tGlobal
    assertFalse "$LINENO tearDown ran" "[ $? -eq 0 ]"

    fComSetConfig -g -k gitproj.testit.test-str -v "test a string"
    grep -q '\[gitproj "testit"\]' $tGlobal
    assertTrue "$LINENO" "[ $? -eq 0 ]"
    grep -q 'test-str = test a string' $tGlobal
    assertTrue "$LINENO" "[ $? -eq 0 ]"

    fComSetConfig -g -i -k gitproj.testit.test-int -v "2K"
    grep -q 'test-int = 2048' $tGlobal
    assertTrue "$LINENO" "[ $? -eq 0 ]"

    fComSetConfig -g -b -k gitproj.testit.test-bool -v "yes"
    grep -q 'test-bool = true' $tGlobal
    assertTrue "$LINENO" "[ $? -eq 0 ]"
} # testComSetConfigGlobal

# --------------------------------
testComGetConfigGlobal()
{
    local tResult
    local tGlobal=$HOME/.gitconfig

    fComSetConfig -g -k gitproj.testit.test-str-get -v "test a string"
    fComSetConfig -g -k gitproj.testit.test-int-get -v "2K"
    fComSetConfig -g -k gitproj.testit.test-bool-get -v "yes"

    tResult=$(fComGetConfig -g -k gitproj.testit.test-str-get)
    assertEquals "$LINENO -g" "test a string" "$tResult"

    tResult=$(fComGetConfig -g -i -k gitproj.testit.test-int-get)
    assertEquals "$LINENO -g" "2048" "$tResult"

    tResult=$(fComGetConfig -g -b -k gitproj.testit.test-bool-get)
    assertEquals "$LINENO -g" "true" "$tResult"
} # testComGetConfigGlobal

# --------------------------------
testComUnsetConfigGlobal()
{
    local tResult
    local tGlobal=$HOME/.gitconfig

    fComSetConfig -g -k gitproj.testit.test-str-unset -v "test unset"
    tResult=$(fComGetConfig -g -k gitproj.testit.test-str-unset)
    assertEquals "$LINENO $tResult" "test unset" "$tResult"
    grep -q "test unset" $tGlobal
    assertTrue "$LINENO" "[ $? -eq 0 ]"

    fComUnsetConfig -g -k gitproj.testit.test-str-unset
    assertTrue "$LINENO" "[ $? -eq 0 ]"
    grep -q "test unset" $tGlobal
    assertFalse "$LINENO" "[ $? -eq 0 ]"
} # testComUnsetConfigGlobal

# --------------------------------
testGitProj()
{
    local tResult

    tResult=$($cBin/git-proj 2>&1)
    assertFalse "$LINENO" "[ $? -eq 0 ]"
    assertContains "$LINENO $tResult" "$tResult" 'git proj [pSubCmd] [pSubCmdOptions] [pComOpt]'

    tResult=$($cBin/git-proj -h 2>&1)
    assertFalse "$LINENO" "[ $? -eq 0 ]"
    assertContains "$LINENO $tResult" "$tResult" 'git proj [pSubCmd] [pSubCmdOptions] [pComOpt]'

    tResult=$($cBin/git-proj -H html 2>&1)
    assertFalse "$LINENO" "[ $? -eq 0 ]"
    assertContains "$LINENO $tResult" "$tResult" '<title>git-proj Usage</title>'

    tResult=$($cBin/git-proj -H int 2>&1)
    assertFalse "$LINENO" "[ $? -eq 0 ]"

} # testGitProj

# --------------------------------
testGitProjInit()
{
    local tResult

    tResult=$($cBin/git-proj-init 2>&1)
    assertContains "$LINENO $tResult" "$tResult" 'Usage'

    tResult=$($cBin/git-proj-init -h)
    assertContains "$LINENO $tResult" "$tResult" 'DESCRIPTION'

    # git proj init [-l pDirPath] [-r] [-e pDirPath] [-h]

    cd $HOME/$cDatProj1
    assertFalse "$LINENO" "[ -d .git ]"
    tResult=$($cBin/git-proj-init -l $PWD)
    assertTrue "$LINENO" "[ -d .git ]"

    assertTrue "$LINENO" "[ -f .gitignore ]"

    # check for git-flow settings
    # git is already in project dir

    # git-flow not installed
}

# ====================
# This should be the last defined function
fComRunTests()
{
    if [ ! -x $cBin/shunit2.1 ]; then
        echo "Error: Missing: $cBin/shunit2.1"
        exit 1
    fi
    if [ "${gpTest:-all}" = "all" ]; then
        # shellcheck disable=SC1091
        . $cBin/shunit2.1
        exit $?
    fi
    # shellcheck disable=SC1091
    . $cBin/shunit2.1 -- $gpTest
    exit $?

    cat <<EOF >/dev/null
=internal-pod

=internal-head3 fComRunTests

Run unit tests for the common functions.

=internal-cut
EOF
} # fComRunTests

# ====================
# Main
export PWD cBin cCurDir cName cPID cVer cHome
export gErr gpDebug gpFacility gpLog gpVerbose

# Test globals
export gpTest gpUnitDebug SHUNIT_COLOR
export cTestSrcDir cTestDestDir cTestFiles

# For cDat defs see: fComSetup()

# Relative to $HOME
export cDatProj1 cDatProj2

# Relative to the corresponding $cDatProjN
export cDatProj1Big cDatProj2Big

# These are simulations of local mount points. Absolute paths.
export cDatMount1 cDatMount2 cDatMount3

# -------------------
# Set current directory location in PWD and cCurDir
if [ -z "$PWD" ]; then
    PWD=$(pwd)
fi
cCurDir=$PWD

# -------------------
# Define the location of this script
cBin=${0%/*}
if [ "$cBin" = "." ]; then
    cBin=$PWD
fi
cd $cBin
cBin=$PWD
cd $cCurDir

# -----
# Optional input: a comma separated list of test function names
gpTest="$*"

. $cBin/gitproj-com.inc
. $cBin/gitproj-init.inc
fComSetGlobals
fComSetup
fComRunTests $gpTest
