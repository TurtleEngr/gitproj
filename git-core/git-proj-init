#!/bin/bash

#--------------------
fUsage()
{
    # Quick help, run this:
    # git-proj-init -h | less

    local pStyle="${1:-usage}"

    fComUsage -s $pStyle -f $cCurDir/$cName
    exit 1

    cat <<\EOF >/dev/null
=pod

=for text ========================================

=for html <hr/>

=head1 NAME git proj init

=head1 SYNOPSIS

    git proj init local [-a] [-l pProjPath]
                        [-r pRawPath] [-k pSymLink]
                        [-s pSize] [-m] [-f] [-h]
        Defaults: [-l $PWD] [-r ../[NAME].raw] [-k raw] [-s 1K] [-m] [-f]

    git proj init remote [-a -d pMountPath] [-r pRawRemotePath ] [-h]
        Defaults: [-r pMountPath/NAME.raw]

=head1 DESCRIPTION

=head2 git proj init local

This will create a local git repo with branches. If git-flow is
installed can will optionally be setup too. After this setup
the remove git repo with "git proj init remote"

If there is a -a option, "git proj init local" will be run with all
the default options, which can be overridden with the options.

If there is no -a option, you will be prompted for the settings.  See
the OPTION section for details.

When the local and remove git repos are setup, all the setings
will be saved to ~/.gitproj.config and
[project]/gitproj/config.$HOSTNAME. Includes are put in ~/.gitconfig
and [project].git/config to point to the gitproj config files.

=head2 git proj init remote

This will create a remote git repo on an external drive.

(Future versions may support repos on remove computers, where you have
rsync access.)

=head1 OPTIONS  git proj init local

=over 4

=item B<-a>

The -a option will automattically run the whole init process with
default settings. The options can be defined to override the default
settings.

=item B<-l pProjPath>

Define the existing project directory. The last directory will be used
for the name of the project. Default: current directory

    Path (-l) [$PWD]? $gpProjPath
        So the project Name will be: ${gpProjPath##*/}

=item B<-r pRawPath>

Set the location for large binary files. It cannot be *in* any of the
project directories. It will be created, if it does not existi. The
path must be relative to the project dir (and not too far away or
cloning the project may not work). The files in the raw directory will
NOT be versioned--only the latest copy will be saved. Default: ../Name.raw

    Raw dir (-r) [../$Name.raw]?
        The README.txt file will point to the project dir.

=item B<-k pSymLink>

Define the symlink name that will point to the Raw dir. It will be
created in the project's top dir. If the Raw dir is moved, this link
will need to be updated. Symlink in the git directories will point to
this dir and the symlinks will be versioned.

    Symlink (-k) [raw]?
        (update the README.txt)

=item B<-s pSize>

Define the "size" for large binary files.

    Size (-s) [1K]?

=item B<-m>

These binary files greater than [1K]  were found in your project dir:

    [file list]

The listed files can be moved to the project's raw diirectory. Paths
will be created in the raw directory that correspond to the project's
directory. A symlink will replace the moved file. The symlink will
point to [raw]

    Move the files (-m) [y/n]?

=item B<-f>

[If git-flow is installed]

    Setup git-flow (-f) [y/n]?

=item B<-h>

=back

=head1 OPTIONS  git proj init remote

=over 4

=item B<-d pMountPath>

Export the git repo to an external drive (or another local dir) This
is usually the removable drive's "top" directory.  Ideally the top
directory should be different across a set of drives, so that the
local "origin" can be used to make sure the proper git repo is round
on the drive. "origin" will be set to $pDirPath

After adding and committing files, run this script to copy this git
repo to a mounted drive (or to another local directory).

A mounted drive should have top directory that is different from other
drives so that the repo can be found with it's "origin" name.

For example, with a mount point: /mnt/usb-video create the remote git
at the top directory video-2019-04-01, with:

 git proj init -e /mnt/usb-video/video-2019-04-01

=item B<-r pRawRemotePath>

 ???
 
=item B<-h>

=back

=head1 RETURN VALUE

 0 - if OK
 !0 - if errors

=for comment =head1 ERRORS

=for comment =head1 EXAMPLES

=for comment=head1 ENVIRONMENT

=for comment=head1 FILES

=head1 SEE ALSO

 git proj
 git proj clone
 git proj add
 git proj push
 git proj pull
 git proj set
 git proj status
 git flow

=for comment =head1 NOTES

=for comment =head1 CAVEATS

=for comment =head1 DIAGNOSTICS

=for comment =head1 BUGS

=for comment =head1 RESTRICTIONS

=head1 AUTHOR

TurtleEngr

=head1 HISTORY

GPLv3 Copyright 2021 by TurtleEngr

$Revision: 1.52 $

=cut

EOF
    exit 1
} # fUsage

# --------------------
fCheckForGit()
{
    if [ ! -d .git ]; then
        fError -m ".git not found in current directory. cd to a directory with .git in it, or use "git proj init -l" to create a new local repo." -l $LINENO
    fi
}

# --------------------
fCheckForNoGit()
{
    if git $cOrigin; then
        git branch
        fError -m ".git already exists for the directory." -l $LINENO
        exit 1
    fi
}

# ========================================
# -l fCreateLocalGit Section

# --------------------
fCheckPkg()
{
    local pPkg=$1

    dpkg -l $pPkg 2>/dev/null | grep -q "^ii *$pPkg"
    return $?
}

# --------------------
fValidProjPath()
{
	local tProjPath=$1

	if [ ! -d $tProjPath ]; then
	   fLog -p Err -m "Project directory not found: $tProjPath" -l $LINENO
	   return 1
	fi

	gpProjPath=$tProjPath
	gpProjName=${gpProjPath##*/}"
	echo "The project Name will be: $gpProjName"
	return 0
}

fGetProjPath()
{
	declare -l tResult

	if [ $gpAuto -ne 0 ]; then
	   if ! fValidProjPath $gpProjPath; then
	      fError -m "Invalid -l pProjPath: $gpProjPath" -l $LINENO
	   fi
	   return 0
	fi
	while true; do
      	    cat <<EOF | fmt
Define the existing project directory. The last directory will be used
for the name of the project. Default: current directory
EOF
	    read -p "Project Path (-l) [$gpProjPath/quit]? " tResult
	    if [ "$tResult" = "quit" ]; then
	      	 fLog -m "Quitting" -l $LINENO
		 exit 1
	    fi
	    if fValidProjPath $tResult; then
	       break
	    fi
	done
} # fGetProjPath

# --------------------
fValidRawPath()
{
	local tRawPath=$1

	if [ "${tRawPath#../}" = "$tRawPath" ]then
	   fLog -p warning -m "RawPath works best if it is relative to ProjPath" -l $LINENO
	fi

	cd $gpProjPath >/dev/null 2>&1
	if [ ! -d $tRawPath ]; then
	   fLog -p err -m "Raw directory not found: $tRawPath" -l $LINENO
	   cd $cCurDir >/dev/null 2>&1
	   return 1
	fi

	cd $tRawPath >/dev/null 2>&1
	echo $PWD | grep -q "/$gpProjName/"
	if [ $? -ne 0 ]; then
	   fLog -p err -m "Raw directory cannot be in $gpProjPath" -l $LINENO
	fi

	gpRawPath=$tRawPath
	cat <<EOF | fmt
The $gpRawPath/README.txt file will point to the project dir.
EOF
	cd $cCurDir >/dev/null 2>&1
	return 0
}

fGetRawPath()
{
	local tResult

	if [ $gpAuto -ne 0 ]; then
	   if ! fValidRawPath $gpRawPath; then
	      fError -m "Invalid -l pRawPath: $gpRawPath" -l $LINENO
	   fi
	   return 0
	fi
	while true; do
      	    cat <<EOF | fmt
Set the location for large binary files. It cannot be *in* any of the
project directories. It will be created, if it does not existi. The
path must be relative to the project dir (and not too far away or
cloning the project may not work). The files in the raw directory will
NOT be versioned--only the latest copy will be saved. Default: ../Name.raw
EOF
	    read -p "Raw dir (-r) [../$Name.raw]? "
	    if [ "$tResult" = "quit" ]; then
	      	 fLog -m "Quitting" -l $LINENO
		 exit 1
	    fi
	    if fValidRawPath $tResult; then
	       break
	    fi
 	done
}

# --------------------
fValidSymLink()
{
	local tSymLinkName=$1

	cd $gpProjPath >/dev/null 2>&1
	if [ ! -d $tSymLinkName ]; then
????	   fLog -p err -m "Raw directory not found: $tRawPath" -l $LINENO
	   cd $cCurDir >/dev/null 2>&1
	   return 1
	fi

	cd $tRawPath >/dev/null 2>&1
	echo $PWD | grep -q "/$gpProjName/"
	if [ $? -ne 0 ]; then
	   fLog -p err -m "Raw directory cannot be in $gpProjPath" -l $LINENO
	fi

	gpRawPath=$tRawPath
	cat <<EOF | fmt
The $gpRawPath/README.txt file will point to the project dir.
EOF
	cd $cCurDir >/dev/null 2>&1
	return 0
}

fGetSymLink()
{
	local tResult

	if [ $gpAuto -ne 0 ]; then
	   if ! fValidSymLink $gpRawPath; then
	      fError -m "Invalid -k pSymLink: $gpSymLink" -l $LINENO
	   fi
	   return 0
	fi

	while true; do
      	    cat <<EOF | fmt
Define the symlink name that will point to the Raw dir. It will be
created in the project's top dir. If the Raw dir is moved, this link
will need to be updated. Symlink in the git directories will point to
this dir and the symlinks will be versioned.

EOF
	    read -p "Symlink (-k) [$gpSynLinkName/quit]? " tResult
	    if [ "$tResult" = "quit" ]; then
	      	 fLog -m "Quitting" -l $LINENO
		 exit 1
	    fi
	    if fValidSymLink $tResult; then
	       break
	    fi
 	done
	return 0
}

# --------------------
fValidSize()
{
	local tSize=$1

	echo $tSize | grep -q '[0-9]+[bkmg]'
	if [ $? -eq 0 ]; then
	   gpMaxSize=$tSize
    	   return 0
	fi
	fLog -m "Size must be numbers followed by b, k, m, or g]" -l $LINENO
	return 1
}

fGetSize()
{
	declare -l tResult
	declare -l tSize

	if [ $gpAuto -ne 0 ]; then
	   if ! fValidSize $gpSize; then
	      fError -m "Invalid -s pSize: $gpSize" -l $LINENO
	   fi
	   return 0
	fi

	while true; do
      	    cat <<EOF | fmt
Define the "size" for large binary files.
EOF
	    read -p "Size (-s) [Nb/Nk/Nm/Ng/quit]? " tResult
	    if [ "$tResult" = "quit" ]; then
	      	 fLog -m "Quitting" -l $LINENO
		 exit 1
	    fi
	    if fValidSize $tResult; then
	       break
	    fi
	done
}

# --------------------
fGetBinaryFiles()
{
    local tFile
    local tFileList=""
    declare -l tResult
    local tSize

    tSize=$(tr 'bBKmg' 'cckMG')

    for tFile in $(find $gpProjPath -type f -size +$gpSize); do
        if [ $(tr -d '[ -~]\0' <$tFile | wc -c) != 0 ]; then
	    tFileList="$tFileList, $tFile"
	fi
    done
    if [ -n "$tFileList ]; then
      	cat <<EOF | fmt
These binary files are greater than $gpSize:

    ${tFileLIst#, }

EOF
	return 1
    fi
    return 0
}

# --------------------
fGetMoveFiles()
{
	if fGetBinaryFiles; then
	   return 0
	fi
	if [ $gpAuto -ne 0 ]; then
	   return 0
	fi

	while true; do
      	    cat <<EOF | fmt
The listed files can be moved to the project's raw diirectory. Paths
will be created in the raw directory that correspond to the project's
directory. A symlink will replace the moved file. The symlink will
point to [raw]

EOF
	
	      read -p "Move the files (-m) [y/n/quit]? " tResult
	      if [ $tResult = "quit" ]; then
	      	 fLog -m "Quitting" -l $LINENO
		 exit 1
	      fi
	      if [ $tResult = "y" ]; then
	      	 gpMove=1
		 break
	      fi
	      if [ $tResult = "n" ]; then
	      	 gpMove=0
		 break
	done
	return 0
}

# --------------------
fGetGetFlow()
{
	declare -l tResult
	local tGitFlowInstalled

	fCheckPkg git-flow
	tGitFlowInstalled=$?

	if [ $tGitFlowInstalled -ne 0 ]  [ $tGitFlowInstalled -ne 0 ]; then
	      fLog -p warning -m "git-flow is not installed." -l $LINENO
	      gpGitFlow=0
	fi
	if [ $gpAuto -ne 0 ]; then
	   return 0
	fi

	while true; do
	      read -p "Setup git-flow (-f) [y/n/quit]? " tResult
	      if [ $tResult = "quit" ]; then
	      	 fLog -m "Quitting" -l $LINENO
		 exit 1
	      fi
	      if [ $tResult = "y" ]; then
	      	 gpGitFlow=1
		 break
	      fi
	      if [ $tResult = "n" ]; then
	      	 gpGitFlow=0
		 break
	done
	return 0
}

# --------------------
fMkGitDir()
{
    cat <<EOF >.gitignore
*.tmp
*~
.cache/
.cvsignore
CVS/
core
nohup.out
proxy/
thumbs/
tmp/
EOF
    set -x >/dev/null 2>&1
    git init
    git add .gitignore *
    git commit -am "Initial commit"
    git branch --move master main
    git branch develop
    git checkout develop
    set +x >/dev/null 2>&1
    if fCheckPkg git-flow; then
        set -x >/dev/null 2>&1
        git flow init -d
    	set +x >/dev/null 2>&1
    fi
    set -x >/dev/null 2>&1
    git branch
    git status
    set +x >/dev/null 2>&1
}

# --------------------
fCreateLocalGit()
{
    fCheckForNoGit

    # Prompt/Response or if -a, just validate the options
    fGetProjPath
    fGetRawPath
    fGetSymLink
    fGetSize
    fGetMoveFiles
    fGetGetFlow

    fMkGitDir
} # fCreateLocalGit

# ========================================
# -e fCreateRemoteGit Section

# --------------------
fCheckPath()
{
    local pPath=$1

    local tName=${PWD##*/}

    if [ ! -d $pPath ]; then
        fError -m "Could not find: $pPath" -l $LINENO
    fi
    if [ ! -w $pPath ]; then
        fError -m "$pPath is not writable for you." -l $LINENO
    fi
    if [ -e $pPath/$tName.git ]; then
        fError -m "$pPath/$tName.git already exists." -l $LINENO
    fi
}

fCheckSpace()
{
    local pPath=$1

    local tAvail
    local tGitSize
    local tRawSize
    local tDesiredSize

    tAvail=$(df -BM $pPath --output=avail | tail -n1)
    tAvail=${tAvail%M}

    tGitSize=$(du -sm .git | awk '{print $1}')
    let tGitSize*=2

    tRawSize=$(du -sm raw | awk '{print $1}')
    let tRawSize*+2

    let tDesiredSize=tGitSize+tRawSize

    if [ $tDesiredSize -gt $tAvail ]; then
        fError -m "There is not enough space at $pPath. $pPath has ${tAvail}MB. .git and raw needs ${tDesiredSize}MB" -l $LINENO
    fi
}

# --------------------
fMkRemote()
{
    local pPath=$1

    local tSrcPath=$PWD
    local tProjName=${PWD##*/}

    set -x >/dev/null 2>&1
    cd $pPath >/dev/null 2>&1
    git clone --bare --local --no-hardlinks --progress -v $tSrcPath/.git
    cd - >/dev/null 2>&1
    git remote add origin $pPath/$tProjName.git
    set +x >/dev/null 2>&1
}

# --------------------
fReport()
{
    echo 'Remote origin is now set to:'
    git $cOrigin
    cat <<EOF
Be sure the disk is mounted and $gpPath exists.
Then you can use: "git push origin develop"
If the mount path is changed, use "git proj set -e" to update the origin.
EOF
}

# --------------------
fCreateRemoteGit()
{
    export cOrigin='config --get remote.origin.url'

    fCheckForGit
    fCheckPath $gpPath
    fCheckSpace $gpPath
    fMkRemote $gpPath
    fReport
} # fCreateRemoteGit

# ====================
# Main
export PWD cBin cCurDir cName cPID cVer
export gErr gpDebug gpFacility gpLog gpVerbose

# Option args
export gpAuto gpLocalPath gpRawPath gpSynLinkName gpMaxSize gpMove
export gpGitFlow gpAction

# -------------------
# Set current directory location in PWD and cCurDir
if [ -z "$PWD" ]; then
    PWD=$(pwd)
fi
cCurDir=$PWD

# -------------------
# Define the location of this script
cBin=${0%/*}
if [ "$cBin" = "." ]; then
    cBin=$PWD
fi
cd $cBin
cBin=$PWD
cd $cCurDir

# -------------------
. $cBin/gitproj-com.inc
fComSetGlobals
gpVerbose=2

if [ $# -eq 0 ]; then
    fError -m "Missing options." -l $LINENO
fi

gpAuto=0
gpLocalPath=$PWD
gpRawPath=../${gpLocal##*/}
gpSynLinkName=raw
gpMaxSize=1K
gpMove=0
gpGitFlow=0
gpAction=""
while getopts :al:r:k:s:mfhH:x tArg; do
    case $tArg in
        # Script arguments
	a)  gpAuto=1 ;;
        l)  gpLocalPath="$OPTARG"
	    gpRawPath=../${gpLocal##*/}
	    ;;
        r)  gpRawPath="$OPTARG" ;;
	k)  gpSynLinkName="$OPTARG" ;;
	s)  gpMaxSize=1K ;;
	m)  gpMove=1 ;;
	f)  gpGitFlow=1
        # Common arguments
        h) fUsage long ;;
        H) fUsage "$OPTARG" ;;
        x) let ++gpDebug ;;
        # Problem arguments
        :) fError "Value required for option: -$OPTARG" $LINENO ;;
        \?) fError "Unknown option: $OPTARG" $LINENO ;;
    esac
done
shift $((OPTIND - 1))
if [ $# -ne 1 ]; then
    fError -m "local or remote needs to be specified." -l $LINENO
fi
case $1 in
     local)  gpAction="fCreateLocalGit" ;;
     remote) gpAction="fCreateRemoteGit" ;;
     *) fError -m "Invalid option: $1. Expeced 'local' or 'remote'." -l $LINENO ;;
esac

$gpAction
exit 0
