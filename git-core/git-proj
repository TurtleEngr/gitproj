#!/bin/bash

export gpCmdName gpBin cCurDir gpCmdVer

fUsage()
{
    # Quick help, run this:
    # git-proj -h | less

    local pStyle="${1:-usage}"

    local tFileList="\
	-f $gpBin/git-proj \
	-f $gpBin/git-proj-init \
	"
    tFileList="$(echo $tFileList)"
	
    	#-f $gpBin/git-proj-remote \
	#-f $gpBin/git-proj-clone \
	#-f $gpBin/git-proj-add \
	#-f $gpBin/git-proj-push \
	#-f $gpBin/git-proj-pull \
	#-f $gpBin/git-proj-add \
	#-f $gpBin/git-proj-move \
	#-f $gpBin/git-proj-rm \
	#-f $gpBin/git-proj-config \
	#-f $gpBin/git-proj-status \
	#-f $gpBin/git-proj-check \

    local tIntFileList="\
        $tFileList \
	-f $gpBin/gitproj-com.inc \
	-f $gpBin/gitproj-com.test \
    "
    tIntFileList="$(echo $tIntFileList)"

    case $pStyle in
        short | usage | man)
            fComUsage -s $pStyle -f $gpBin/$gpCmdName
            ;;
        long | text | md)
            fComUsage -s $pStyle $tFileList
            ;;
        html)
            fComUsage -s $pStyle -t "git proj Usage" $tFileList
            ;;
        int)
            fComUsage -i -s long $tIntFileList
            ;;
        int-html)
            fComUsage -i -s html -t "$gpCmdName Internal Doc" $tIntFileList
            ;;
        int-md)
            fComUsage -i -s md $tIntFileList
            ;;
        *)
            fComUsage -s usage -f $gpBin/$gpCmdName
            ;;
    esac
    exit 1

    cat <<\EOF >/dev/null
=pod

=head1 NAME git proj

This implements the "git proj" subcommand, for managing large binary
files, and repositiories on external drives.

=head1 SYNOPSIS

 	git proj [pSubCmd] [pSubCmdOptions] [pComOpt]

 	pSubCmd: init, clone, push, pull, add, move, rm, config, status, check
 	pComOpt: [-h] [-H pStyle] [-x]
 
=head1 DESCRIPTION

The "git proj" subcommand supports using git repo for versioning files to
locally mounted external drives.

git-proj also mostly solves the issue with large binary files causing
git repo "bloat". Large files are not versioned, they are only
copied. So if a version important, just rename the file.  (symlinks
are used and versioned to point to the large binary files.)

This is a much simpler implementation than git-lfs for managing the
versioning of large binary files. Since the large files are not
versioned, i.e. only the last version is saved, this is a comompromize
on having "perfect" version control of the files.

The main inspiration for the proj tool came from the need to
versioning video projects. Video files are HUGE, yet they don't change
much. Since most video files are rendered from files that do not
change, it is only important to version the video editor's file, so
that you can recreate a particular video file version. Since rendering
takes time you will want to save the rendered file. But there is usually
no need to save every rendered version.

=head1 OPTIONS

=head2 pComOpt

=over 4

=item B<-h>

Output this "long" usage help. See "-H long"

=item B<-H pStyle>

pStyle is used to select the type of help and how it is formatted.

Styles:

	short|usage - Output short usage help as text.
	long|text   - Output long usage help as text. All subcommands.
	man 	    - Output long usage help as a man page.
	html 	    - Output long usage help as html. All subcommands.
	md 	    - Output long usage help as markdown.
	int 	    - Also output internal documentation as text.
	int-html    - Also output internal documentation as html.
	int-md 	    - Also output internal documentation as markdown.

=item B<-v>

Verbose output. Default is is only output (or log) messages with
level "warning" and higher.

 -v - output "notice" and higher.
 -vv - output "info" and higher.

=item B<-x>

Set the gpDebug level. Add 1 for each -x.
Or you can set gpDebug before running the script.

See: fLog (Internal documentation)

=back

=head2 pSubCmd

=over 4

=item B<init - Initialize the git project repo>

 git proj init [-l [pDirPath]] [-e pDirPath] [-r [pDirPath]

=item B<clone - Clone a previously saved project>

 git proj clone pExternalPath

=item B<add - Add a large binary file to the "raw" remote>

 git proj add pFilePath

=item B<push - Push files to the "raw" remote>

 git proj push [-b]

=item B<pull - Pull files from the "raw" remote>

 git proj pull [-b]

=item B<config - Redefine config values>

 git proj config [-l pExternalPath] [-e pRawPath]
 
=item B<status - Show the staus of "raw" files, and more>

 git proj status [-b] [-v]

=back

=head2 ~/.gitconfig

Source: gpDoc/config/gitconfig.default

If this doesn't exist, git proj init will create it from "Source":

This will be put in ~/.gitconfig

    [include]
        path = ~/.gitproj.config.global

=head2 ~/.gitproj.config.global

Source: gpDoc/config/gitproj.config.global

git proj init local, will create the initial ~/.gitproj.config.

=head2 top-dir/.git/config

This will be put in the initial the local .git/config file:

    [include]
        path = ../.gitproj.config.HOSTNAME

Where HOSTNAME will be set to $HOSTNAME. This allows for different
locations of file, based on the host. For example the remote-raw-url
(mount point) could be very different between hosts.

=head2 top-dir/.gitproj.config.$HOSTNAME

Initial Source: gpDoc/config/gitproj.config.HOSTNAME

This will be created when git project repo is first created on a host.

This will be put at the beginning of the config file, so that common
project defaults can be defined. Then .gitproj.config.HOSTNAME can
override variables. Any changed to the variables in
.gitproj.config.local variables will be written to
.gitproj.config.HOSTNAME

=head2 top-dir/.gitproj.config.local

Source: gpDoc/config/gitproj.config.local

Uncomment the variables that should override ~/.gitconfig or
~/.gitproj.config.global. If the variables are host specific, then the
variable should be put in the correspoinding .gitproj.config.$HOSTNAME
file.

	[gitproj "config"]
		ver = 1.0
		syslog = true
		facility = user

		bin = /usr/lib/git-core
		# bin = $(git --exec-path)

		doc = /usr/share/doc/git-proj
		test = /usr/share/doc/git-proj/test

	 	# See .gitproj.config.local and/or .gitproj.config.$HOSTNAME
	
		# States: not-setup, setup-err, config-err, OK
		proj-status = not-set-up
	
		# origin-url with path and .git removed
		name = TBD
	
		# This should only be changed on the matching host
		# git rev-parse --show-toplevel
		top-dir = TBD
	
			# If $t = $r, then set hardlink to true
		# t=$(df -BM top-dir --output=source | tail -n 1)
		# r=$(df -BM raw-dir --output=source | tail -n 1)
		hardlink = no
	
		# Local mount examples
		remote-raw-dir = TBD
		#remote.origin.url = /MOUNT-DIR/DIR/NAME.git

		# Remote examples (not implemented. TBD)
		#remove-raw-url = joe@example.com:/repo/git/video-2021-09-24/NAME.raw
		#remote.origin-url=USER@example.com:/repo/git/video-2021-09-24/NAME.git
		#remote.origin-url=git@github.com:TurtleEngr/gitproj.git

		# Set by init. Changing these will require manual repair.
		# If no ~ or /, this is relative to top-dir, create:
                #  dir/Name.raw
		# This should NOT be in a git dir.
		# Relative to top-dir
		local-raw-dir-pat = ..

		# Relative to top-dir; cd top-dir; ln -s
                # raw-dir/name.raw symlink
		# This should be in a git dir.
		# Relative to top-dir
		local-raw-symlink = raw

	[gitproj "hook"]
		# If pre-commit-enabled = true, pre-commit hook script will be
		# installed into .git/hooks/
		# Relative to gpDoc
		source = hooks/pre-commit
		pre-commit-enabled = true
		check-file-names = true
		check-for-big-files = true
		# End size with b, k, m, or g
		binary-file-size-limit = 1k

=head2 Env. Var. Config

These are globals that may affect how the script runs. Just about all
of these globals that begin with "gp" can be set and exported before
the script is run. That way you can set your own defaults, by putting
them in your ~/.bashrc or ~/.bash_profile files.

The the "common" CLI flags will override the initial variable settings.

=over 4

=item B<gpSysLog>

If set to 0, log messages will only be sent to stderr.

If set to 1, log messages will be sent to stderr and syslog.

See -l, fLog and fErr for details

Default: 0

=item B<gpFacility>

Log messages sent to syslog will be sent to the "facility" specified
by by gpFacility.

"user" log messages will be sent to /var/log/user.log, or
/var/log/syslog, or /var/log/messages.log

See: fLog

Default: user

Allowed facility names:

 local0 through local7 - local system facilities
 user - misc scripts, generic user-level messages
 auth - security/authorization messages
 authpriv - security/authorization messages (private)
 cron - clock daemon (cron and at)
 daemon - system daemons without separate facility value
 ftp - ftp daemon
 kern - kernel  messages  (these  can't be generated from user processes)
 lpr - line printer subsystem
 mail - mail subsystem
 news - USENET news subsystem
 syslog - messages generated internally by syslogd(8)
 uucp - UUCP subsystem

These are some suggested uses for the localN facilities:

 local0 - system or application configuration
 local1 - application processes
 local2 - web site errors
 local3 - web site access
 local4 - backend processes
 local5 - publishing
 local6 - available
 local7 - available

=item B<gpVerbose>

If set to 0, only log message at "warning" level and above will be output.

If set to 1, all non-debug messages will be output.

See -v, fLog

Default: 0

=item B<gpDebug>

If set to 0, all "debug" and "debug-N" level messages will be skipped.

If not 0, all "debug" level messages will be output.

Or if "debug-N" level is used, then if gpDebug is <= N, then the
log message will be output, otherwise it is skipped.

See -x

=item B<gpUnitDebug>

If set to non-zero, then the fUDebug function calls will output
the messages when in test functions.

See gitproj-com.test

=back

=head1 RETURN VALUE

=head1 ERRORS

=head1 EXAMPLES

=head1 ENVIRONMENT

See Globals section for details.

HOME,USER, gpSysLog, gpFacility, gpVerbose, gpDebug, gpUnitDebug

=head1 FILES

=head1 SEE ALSO

shunit2.1

=head1 NOTES

=head1 CAVEATS

[Things to take special care with; sometimes called WARNINGS.]

=head1 DIAGNOSTICS

=head2 Testing

In the top git cloned directory, run the unit test functions with the
command:

    gitproj-com.test

will run all of the functions that begin with "test".

    gitproj-com.test [testName,testName,...]

This will run the listed testName functions.

For more details about shunit2 (or shunit2.1), see
shunit2/shunit2-manual.html
L<Source|https://github.com/kward/shunit2>

See shunit2, shunit2.1, and global: gpUnitDebug

Also for more help, use the "-H int" option.

=head1 BUGS

=head1 RESTRICTIONS

=head1 AUTHOR

TurtleEngr

=head1 HISTORY

(c) Copyright 2021 by TurtleEngr

$Revision: 1.0 $

=cut
EOF
} # fUsage

# ====================
# Main

export gpCmdName=${BASH_SOURCE##*/}
export tSrc=${BASH_SOURCE##*/}

# -------------------
# Set current directory location in PWD and cCurDir
if [ -z "$PWD" ]; then
    PWD=$(pwd)
fi
if [ -z "$cCurDir" ]; then
    cCurDir=$PWD
fi

# -------------------
# Define the location of the com script if not already set
if [ -z "$gpBin" ]; then
    gpBin=${0%/*}
    if [ "$gpBin" = "." ]; then
        gpBin=$PWD
    fi
    cd $gpBin >/dev/null 2>&1
    gpBin=$PWD
    cd - >/dev/null 2>&1
fi

# -----
. $gpBin/gitproj-com.inc

# shellcheck disable=SC2016
gpCmdVer='$Revision: 1.49 $'

#fSetGlobals
fComSetGlobals

if [ $# -eq 0 ]; then
    fUsage usage
fi

# -------------------
# Get Args Section
if [ $# -eq 0 ]; then
    fError -m "Missing options." -l $tSrc:$LINENO
fi
pShowVer=0
while getopts :vVhH:lx tArg; do
    case $tArg in
    	v|V) pShowVer=1;;
        # Common arguments
        h) fUsage long ;;
        H) fUsage "$OPTARG" ;;
        l) gpSysLog=true ;;
        x) let gpDebug=gpDebug+1 ;;
        # Problem arguments
        :) fError -m "Value required for option: $OPTARG" -l $tSrc:$LINENO ;;
        \?) fError -m "Unknown option: $OPTARG" -l $tSrc:$LINENO ;;
    esac
done
shift $((OPTIND - 1))
if [ $# -ne 0 ]; then
    if [ "$1" = "version" ]; then
        pShowVer=1
    else
        fError -m "Unexpected option: $*" -l $tSrc:$LINENO
    fi
fi

if [ $pShowVer -ne 0 ]; then
    echo $cGitProjVersion
fi

exit 0
