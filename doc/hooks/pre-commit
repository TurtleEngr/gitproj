#!/bin/bash
# This file is copied from gitproj doc/hooks/pre-commit to .git/hooks
# These gitproj config hook vars control this script:

# pre-commit-enabled = if true, this script is enabled
# check-file-names = if true, "abnormal" file names will not be allowed
# check-for-big-files = if true, files bigger than
#     binary-file-size-limit cannot be committed.
# binary-file-size-limit = defines the max size. # of bytes if no suffix.
#     Suffixes: k,m,g

# --------------------
export gVerbose=true
export gAgainst
export gFileList=""
export LC_ALL=C
export gErr=0
export gSrc=${BASH_SOURCE##*/}

fIsBinary()
{
    local pFile="$1"
    grep -Hm1 '^' <"$pFile" | grep -q '^Binary'
    # Copied from: https://unix.stackexchange.com/questions/275516/is-there-a-convenient-way-to-classify-files-as-binary-or-text
}

fReport()
{
    local pZero=$1
    local pResult=$2
    local pFile=$3
    local pMsg="$4"
    local pLine=$5
    local tErr=0

    if [ $pZero -eq 0 ] && [ $pResult -ne 0 ]; then
        tErr=1
    fi
    if [ $pZero -eq 1 ] && [ $pResult -eq 0 ]; then
        tErr=1
    fi
    if [ $tErr -ne 0 ]; then
        let ++gErr
        if [ "$gVerbose" = "true" ]; then
            echo "$pFile $pMsg [$gSrc:$pLine]"
        fi
        gFileList="$gFileList $pFile"
        git reset HEAD $pFile
        if [ "${pFile%!*}" != "$pFile" ]; then
            pFile=$(echo $pFile | tr '!' ' ')
            git reset HEAD "$pFile"
        fi
        return 1
    fi
    return 0
} # fReport

# --------------------
fEnabled()
{
    tEnabled=$(git config --get --bool gitproj.hook.pre-commit-enabled)
    if [ "$tEnabled" != "true" ]; then
        exit 0
    fi
    return 0
} # fEnabled

# --------------------
fCheckFileNames()
{
    local tFile
    local tResult
    local tPart

    tResult=$(git config --get --bool gitproj.hook.check-file-names)
    if [ "$tResult" != "true" ]; then
        return 0
    fi

    # Spaces in names really f**ks up scripts, so replace them with '!'
    # another invalid character
    gFileList=""
    for tFile in $(git diff --cached --name-only --diff-filter=ACR $gAgainst | tr ' ' '!'); do
        tResult=$(echo -n "$tFile" | tr -d '[ -~]' | wc -c)
        fReport 0 $tResult $tFile "has non-printable chars in name" $LINENO || continue

        tResult=$(echo -n "$tFile" | tr -d 'a-zA-Z0-9/._-' | wc -c)
        fReport 0 $tResult $tFile "has illegal chars in name" $LINENO || continue

        tResult=$(echo -n "$tFile" | grep -Ei '(^|/)(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])(\.|$)' | wc -c)
        fReport 0 $tResult $tFile "has reserved words in name" $LINENO || continue

        echo -n "$tFile" | grep -Eq '(\.\.+$)'
        fReport 1 $? $tFile "has just periods in name" $LINENO || continue

        echo -n "$tFile" | grep -Eq '\.$'
        fReport 1 $? $tFile "has trailing period" $LINENO || continue
    done

    if [ -n "$gFileList" ]; then
        let ++gErr
        echo
        echo "These files are not valid:"
        echo "$gFileList" | fmt -w 10
        cat <<EOF

Names can only use letters, numbers, hypen, dash, and periods.
Names cannot begin with hyphens or end with periods.
Names cannot be all periods.
If you had a filename with spaces in it, the spaces were replaced with '!'.

EOF
        return 1
    fi
    return 0
} # fCheckFileNames

# --------------------
fCheckWhiteSpace()
{
    local tFile

    tResult=$(git config --get --bool gitproj.hook.check-whitespace)
    if [ "$tResult" != "true" ]; then
        return 0
    fi

    # If there are whitespace errors, print the offending file names
    for tFile in $(git diff-index --color=never --check --cached $gAgainst -- | tr ' ' '!' | awk '/trailing/ {print $1}'); do
        tFile=${tFile%%:*}
        fReport 0 1 $tFile "trailing whitespace" $LINENO
    done
    if [ -n "$gFileList" ]; then
        let ++gErr
        echo
        echo "These files had trailing whitespaces:"
        eccho "$gFileList" | fmt -w 10
        echo
    fi
    return 0
} # fCheckWhiteSpace

# --------------------
fCheckNotRaw()
{
    local tFile
    local tResult

    tResult=$(git config --get --bool gitproj.hook.check-in-raw)
    if [ "$tResult" != "true" ]; then
        return 0
    fi

    gFileList=""
    for tFile in $(git diff --cached --name-only --diff-filter=ACR $gAgainst | tr ' ' '!'); do
        echo $tFile | grep -q '^raw/'
        fReport 1 $? $tFile "Do not commit files in raw/" $LINENO
    done

    if [ -n "$gFileList" ]; then
        let ++gErr
        tResult=$(git config --get gitproj.config.remote-raw-dir)
        echo
        echo "These files should not be managed in git:"
        echo "$gFileList" | fmt -w 10
        cat <<EOF | fmt

Use "git proj push" to save binary files, in raw/, to $tResult
Also, run "git proj -h | less" for a description of how git-proj
can manage large binary files and keep your git repo nimble.

EOF
        return 1
    fi
    return 0
} # fCheckNotRaw

# --------------------
fCheckBigFiles()
{
    local tMaxSize
    local tSize
    local tFile
    local tResult

    tResult=$(git config --get --bool gitproj.hook.check-for-big-files)
    if [ "$tResult" != "true" ]; then
        return 0
    fi

    tMaxSize=$(git config --get --int gitproj.hook.binary-file-size-limit)

    gFileList=""
    for tFile in $(git diff --cached --name-only --diff-filter=ACR $gAgainst | tr ' ' '!'); do
        if [ ! -f "$tFile" ]; then
            continue
        fi
        if ! fIsBinary $tFile; then
            continue
        fi
        tSize=$(ls -l $tFile | awk '{print $5}')
        if [ $tSize -gt $tMaxSize ]; then
            fReport 0 1 $tFile "size $tSize > $tMaxSize" $LINENO
        fi
    done
    if [ -n "$gFileList" ]; then
        let ++gErr
        echo
        echo "These files were > $tMaxSize:"
        echo "$gFileList" | fmt -w 10
        cat <<EOF | fmt

Large binary files should NOT be committed to git.  Move the files to
the top raw/ dir, or use "git proj move FILE" to move the file to the
raw/ dir and it will make a symlink to the files old location. Or
change config gitproj.hook.binary-file-size-limit to be larger. Or
disable this check, and live with a massive git repo.

EOF
        return 1
    fi
    return 0
} # fCheckBigFiles

# ========================================
# Main

gAgainst=HEAD
if ! git rev-parse --verify HEAD >/dev/null 2>&1; then
    # Initial commit: diff against an empty tree object
    gAgainst=4b825dc642cb6eb9a060e54bf8d69288fbee4904
fi

gVerbose=$(git config --get --bool gitproj.hook.verbose)
fEnabled
fCheckFileNames
fCheckWhiteSpace
fCheckNotRaw
fCheckBigFiles

exit $gErr
