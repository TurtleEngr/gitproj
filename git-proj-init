#!/bin/bash

#--------------------
fUsage()
{
    exit 1

    cat <<\EOF >/dev/null

git proj init [-l [pDirPath]] [-e pDirPath] [-r [pDirPath]

    -l intialize a local git repo in pDirPath. If pDirPath is not
       specified then $PWD will be used. The git repo will be named
       after the last directory in pDirPath.
       
    -e export the git repo to an external drive (or another local dir)
       This is usually the removable drive's "top" directory.  Ideally
       the top directory should be different across a set of drives,
       so that the local "origin" can be used to make sure the proper
       git repo is round on the drive. "origin" will be set to
       $pDirPath
       
    -r define the "raw" file dir for files that will not be versioned.
       If pDirPath is not specified, then
       [top_git_dir]/../[git_dir_name].raw will be used. In
       [top_git_dir] this symlink will be created:
       raw->../[git_dir_name].raw

    (git-proj-init, proj-init-local, proj-init-remote, proj-init-raw)
	
Usage:
	proj-new-local -n

Description
	Create a new git repo in this directory. After adding and
	committing files, use "proj-new-remote" to push the repo to a
	mounted drive.
	
Dependencies
	packages: git, git-flow 
EOF
    exit 1
}

# --------------------
fCheckForPkg()
{
    local pPkg=$1

    if ! (dpkg -l $pPkg 2>/dev/null | grep -q "^ii *$pPkg"); then
        echo "Error: Missing package: $pPkg"
        exit 1
    fi
}

# --------------------
fCheckForGit()
{
    if git $cOrigin; then
        echo "Error: .git already exists for the directory."
        git branch
        exit 1
    fi
}

# --------------------
fCreateGitDir()
{
    cat <<EOF >.gitignore
*.tmp
*~
.cache/
.cvsignore
CVS/
core
nohup.out
proxy/
thumbs/
tmp/
EOF
    set -x
    git init
    git flow init
    git checkout develop
    git add .gitignore
    git status
    set +x
}

# ====================
# Main

if [ $# -eq 0 ]; then
    fUsage
fi

export cOrigin='config --get remote.origin.url'

fCheckForPkg git
fCheckForPkg git-flow
fCheckForGit
fCreateGitDir

exit 0
#!/bin/bash

#!/bin/bash

#--------------------
fUsage()
{
    cat <<EOF
Usage:
	proj-new-remote pPath
	
Description
	After adding and committing files, run this script to copy
	this git repo to a mounted drive (or to another local
	directory).

	A mounted drive should have top directory that is different
	from other drives so that the repo can be found with it's
	"origin" name.

Example
	With a mount point: /mnt/usb-video create the remote git at
	the top directory video-2019-04-01, with:

	proj-new-remote /mnt/usb-video/video-2019-04-01
EOF
    exit 1
}

# --------------------
fCheckForGit()
{
    if [ ! -d .git ]; then
        cat <<EOF
Error: .git not found in current directory. cd to directory with .git
in it, or use proj-new-local to create a new local repo.
EOF
        exit 1
    fi
}

# --------------------
fCheckPath()
{
    local pPath=$1

    local tName=${PWD##*/}

    if [ ! -d $pPath ]; then
        echo "Error: Could not find: $pPath"
        exit 1
    fi
    if [ ! -w $pPath ]; then
        echo "Error: $pPath is not writable for you."
        exit 1
    fi
    if [ -e $pPath/$tName.git ]; then
        echo "Error: $pPath/$tName.git already exists."
        exit 1
    fi
}

fCheckSpace()
{
    local pPath=$1

    local tAvail
    local tGitSize

    tAvail=$(df -BM $pPath --output=avail | tail -n1)
    tAvail=${tAvail%M}

    tGitSize=$(du -sm .git | awk '{print $1}')
    let tGitSize*=2

    if [ $tGitSize -gt $tAvail ]; then
        echo "Error: There is not enough space at $pPath"
        echo "$pPath has ${tAvail}MB"
        echo ".git needs ${tGitSize}MB"
        exit 1
    fi
}

# --------------------
fCreateRemote()
{
    local pPath=$1

    local tSrcPath=$PWD
    local tProjName=${PWD##*/}

    set -x
    cd $pPath &>/dev/null
    git clone --bare --local --no-hardlinks --progress -v $tSrcPath/.git
    cd - &>/dev/null
    git remote add origin $pPath/$tProjName.git
    set +x
}

fReport()
{
    echo 'Remote origin is now set to:'
    git $cOrigin
    cat <<EOF
Be sure the disk is mounted and $gpPath exists.
Then you can use: "git push origin develop"
If the mount path is changed, use proj-remote-location update origin.
EOF
}

# ====================
# Main

if [ $# -ne 1 ]; then
    fUsage
fi

gpPath=$1

export cOrigin='config --get remote.origin.url'

fCheckForGit
fCheckPath $gpPath
fCheckSpace $gpPath
fCreateRemote $gpPath
fReport

exit 0
